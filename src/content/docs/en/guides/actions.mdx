---
title: Actions
description: Learn how to create type-safe server functions you can call from anywhere.
i18nReady: true
---

import { Steps } from '@astrojs/starlight/components';
import Since from '~/components/Since.astro';
import ReadMore from '~/components/ReadMore.astro';

<p><Since v="4.14" /></p>

Astro Actions allow you to define and call backend functions with type-safety. Actions perform data fetching, JSON parsing, and input validation for you. This can greatly reduce the amount of boilerplate needed compared to using an [API endpoint](/en/guides/endpoints/).

Use actions instead of API endpoints for seamless communication between your client and server code and to:

- Automatically validate JSON and form data inputs using [Zod validaton](https://zod.dev/?id=primitives).
- Generate type-safe functions to call your backend from the client and even [from HTML form actions](#call-actions-from-an-html-form-action). No need for manual `fetch()` calls.
- Standardize backend errors with the `ActionError` object.

## Basic usage

Actions are defined in a `server` object exported from `src/actions/index.ts`:

```ts title="src/actions/index.ts"
import { defineAction } from 'astro:actions';
import { z } from 'astro:schema';

export const server = {
  myAction: defineAction({ /* ... */ })
}
```

Your actions are available as functions from the `astro:actions` module. Import `actions` and call them client-side within a [UI framework component](/en/guides/framework-components/), [a form POST request](#call-actions-from-an-html-form-action), or by using a `<script>` tag in an Astro component.

When you call an action, it returns an object with either `data` containing the JSON-serialized result, or `error` containing thrown errors.

```astro title="src/pages/index.astro"
---
---

<script>
import { actions } from 'astro:actions';

async () => {
  const { data, error } = await actions.myAction({ /* ... */ });
}
</script>
```

### Write your first action

Follow these steps to define an action and call it in a `script` tag in your Astro page.

<Steps>

1. Create a `src/actions/index.ts` file and export a `server` object.

    ```ts title="src/actions/index.ts"
    export const server = {
      // action declarations
    }
    ```

2. Import the `defineAction()` utility from `astro:actions`, and the `z` object from `astro:schema`.

    ```ts ins={1-2} title="src/actions/index.ts"
    import { defineAction } from 'astro:actions';
    import { z } from 'astro:schema';

     export const server = {
      // action declarations
    }

3. Use the `defineAction()` utility to define a `getGreeting` action. The `input` property will be used to validate input parameters with a [Zod](https://zod.dev) schema and the `handler()` function includes the backend logic to run on the server.

    ```ts ins={5-12} title="src/actions/index.ts"
    import { defineAction } from 'astro:actions';
    import { z } from 'astro:schema';

    export const server = {
      getGreeting: defineAction({
        input: z.object({
          name: z.string(),
        }),
        handler: async (input) => {
          return `Hello, ${input.name}!`
        }
      })
    }
    ```

4. Create an Astro component with a button that will fetch a greeting using your `getGreeting` action when clicked.

    ```astro title="src/pages/index.astro"
    ---
    ---

    <button>Get greeting</button>

    <script>
    const button = document.querySelector('button');
    button?.addEventListener('click', async () => {
      // Show alert pop-up with greeting from action
    });
    </script>
    ```

5. To use your action, import `actions` from `astro:actions` and then call `actions.getGreeting()` in the click handler. The `name` option will be sent to your action’s `handler()` on the server and, if there are no errors, the result will be available as the `data` property.

    ```astro title="src/pages/index.astro" ins={7, 12-13}
    ---
    ---

    <button>Get greeting</button>

    <script>
    import { actions } from 'astro:actions';

    const button = document.querySelector('button');
    button?.addEventListener('click', async () => {
      // Show alert pop-up with greeting from action
      const { data, error } = await actions.getGreeting({ name: "Houston" });
      if (!error) alert(data);
    })
    </script>
    ```

</Steps>

<ReadMore>See the full Actions API documentation for details on [`defineAction()`](/en/reference/api-reference/#defineaction) and its properties.</ReadMore>

## Organizing actions

All actions in your project must be exported from the `server` object in the `src/actions/index.ts` file. You can define actions inline or you can move action definitions to separate files and import them. You can even group related functions in nested objects.

For example, to colocate all of your user actions, you can create a `src/actions/user.ts` file and nest the definitions of both `getUser` and `createUser` inside a single `user` object.

```ts
// src/actions/user.ts
import { defineAction } from 'astro:actions';

export const user = {
  getUser: defineAction(/* ... */),
  createUser: defineAction(/* ... */),
}
```

Then, you can import this `user` object into your `src/actions/index.ts` file and add it as a top-level key to the `server` object alongside any other actions:

```ts title="src/actions/index.ts" ins={1,5}
import { user } from './user';

export const server = {
  myAction: defineAction({ /* ... */ }),
  user,
}
```

Now, all of your user actions are callable from the `actions.user` object:

- `actions.user.getUser()`
- `actions.user.createUser()`


## Handling returned data

Actions return an object containing either `data` with the type-safe return value of your `handler()`, or an `error` with any backend errors. Errors may come from validation errors on the `input` property or thrown errors within the `handler()`.

### Checking for errors

It's best to check if an `error` is present before using the `data` property. This allows you to handle errors up-front and ensures `data` is defined without an `undefined` check.

```ts
const { data, error } = await actions.example();

if (error) {
  // handle error cases
  return;
}
// use `data`
```

### Accessing `data` directly without an error check

If you want to skip error handling while prototyping, or are using a library that will catch errors for you, you can use the `.orThrow()` property on your action call. With `.orThrow()`, unexpected errors will be thrown and the action’s `data` will be returned directly.

This example calls a `likePost()` action that returns the updated number of likes as a `number` from the action `handler`:

```ts ins="orThrow"
const updatedLikes = await actions.likePost.orThrow({ postId: 'example' });
//    ^ type: number
```

### Handling backend errors in your action

You may need to throw an error from your action `handler()`, such as "not found" errors when a database entry is missing, or "unauthorized" errors when a user is not logged in.

Instead of returning `undefined` in these cases, you can throw errors using the provided `ActionError` object. This has two main benefits:

- You can set a status code like `404 - Not found` or `401 - Unauthorized`. This improves debugging errors in both development and in production by letting you see the status code of each request.

- In your application code, all errors are passed to the `error` object on an action result. This avoids the need for `undefined` checks on data, and allows you to display targeted feedback to the user depending on what went wrong.

#### Creating an `ActionError`

To throw an error, import the `ActionError()` class from the `astro:actions` module. Pass it a human-readable status `code` (e.g. `"NOT_FOUND"` or `"BAD_REQUEST"`), and an optional `message` to provide further information about the error.

This example throws an error from a `likePost` action when a user is not logged in, after checking a hypothetical "user-session" cookie for authentication:

```ts title="src/actions/index.ts" ins="ActionError" ins={9-12}
import { defineAction, ActionError } from "astro:actions";
import { z } from "astro:schema";

export const server = {
  likePost: defineAction({
    input: z.object({ postId: z.string() }),
    handler: async (input, ctx) => {
      if (!ctx.cookies.has('user-session')) {
        throw new ActionError({
          code: "UNAUTHORIZED",
          message: "User must be logged in.",
        });
      }
      // Otherwise, like the post
    },
  }),
};
```

#### Handling an `ActionError`

To handle this error, you can call the action from your application and check whether an `error` property is present. This property will be of type `ActionError` and contain your `code` and `message`.

In the following example, a `LikeButton.tsx` component calls the `likePost()` action when clicked. If an authentication error occurs, the `error.code` attribute is used to determine whether to display a login link:

```tsx title=src/components/LikeButton.tsx ins="if (error.code === 'UNAUTHORIZED') setShowLogin(true);"
import { actions } from 'astro:actions';
import { useState } from 'preact/hooks';

export function LikeButton({ postId }: { postId: string }) {
  const [showLogin, setShowLogin] = useState(false);
  return (
    <>
      {
        showLogin && <a href="/signin">Log in to like a post.</a>
      }
      <button onClick={async () => {
        const { data, error } = await actions.likePost({ postId });
        if (error?.code === 'UNAUTHORIZED') setShowLogin(true);
        // Early return for unexpected errors
        else if (error) return;
        // update likes
      }}>
        Like
      </button>
    </>
  )
}
```

### Handling client redirects

You may need to redirect to a new page when an action succeeds. When calling actions from the client, you can integrate with a client-side library like `react-router`, or you can use Astro's [`navigate()` function](/en/guides/view-transitions/#trigger-navigation) to redirect to a new page.

This example navigates to the homepage after a `logout` action returns successfully:

```tsx title=src/pages/LogoutButton.tsx {2,7-8}
import { actions } from 'astro:actions';
import { navigate } from 'astro:transitions/client';

export function LogoutButton() {
  return (
    <button onClick={async () => {
      const { error } = await actions.logout();
      if (!error) navigate('/');
    }}>
      Logout
    </button>
  );
}
```

## Accepting form data from an action

Actions accept JSON data by default. If you are using an HTML form, you can switch an action to accept form data by adding the `accept: 'form'` parameter to your `defineAction()` call:

```ts title="src/actions/index.ts" ins="accept: 'form'"
import { defineAction } from 'astro:actions';
import { z } from 'astro:schema';

export const server = {
  comment: defineAction({
    accept: 'form',
    input: z.object(/* ... */),
    handler: async (input) => { /* ... */ },
  })
}
```

### Validating form data

Astro will smartly parse form data to an object, mapping each form input based on the input `name`. Your action's `input` property will validate these values using the `z.object()` validator. You can also omit the `input` property to receive the raw `FormData` object in your action handler.

This example creates a validated newsletter form that accepts a user's email and requires a "terms of service" agreement checkbox. First, provide an appropriate `name` for each input:

```astro title="src/components/Newsletter.astro 'name="email"' 'name="terms"'
<form>
  <input required type="email" name="email" />
  <label>
    <input required type="checkbox" name="terms">
    I agree to the terms of service
  </label>
  <button>Sign up</button>
</form>
```

Then, create a `newsletter()` action to handle the `email` and `terms` provided. Validate the `email` field using the `z.string().email()` validator, and the `terms` checkbox using `z.boolean()`:

```ts title="src/actions/index.ts" ins={7-10}
import { defineAction } from 'astro:actions';
import { z } from 'astro:schema';

export const server = {
  newsletter: defineAction({
    accept: 'form',
    input: z.object({
      email: z.string().email(),
      terms: z.boolean(),
    }),
    handler: async ({ email, terms }) => { /* ... */ },
  })
}
```

<ReadMore>[Check the `input` API reference](/en/reference/api-reference/#input-validator) for all available form validators.</ReadMore>

You can then submit a form request using either client code or an [HTML form action](#call-actions-from-an-html-form-action). This example overrides the form's default `onSubmit()` behavior to call `actions.newsletter()`, and redirects to `/confirmation` using the `navigate()` function:

```astro title=src/components/Newsletter.astro ins={11-20}
<form>
  <input required type="email" name="email" />
  <label>
    <input required type="checkbox" name="terms">
    I agree to terms of service
  </label>
  <button>Sign up</button>
</form>

<script>
  import { actions } from 'astro:actions';
  import { navigate } from 'astro:transitions/client';

  const form = document.querySelector('form') as HTMLFormElement;
  form.addEventListener('submit', async (e) => {
    e.preventDefault();
    const formData = new FormData(form);
    const { error } = await actions.newsletter(formData);
    if (!error) navigate('/confirmation');
  })
</script>
```

### Displaying form input errors

You can validate form inputs before submission [using native HTML form validation attributes](https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation#using_built-in_form_validation) like `required`, `type="email"`, and `pattern`. Still, you may have more complex `input` validation on the backend that you need to surface to the user.

To retrieve input errors, use the `isInputError()` utility to check whether an `error` was caused by invalid input. If so, `error` will contain a `fields` object with error messages for each input name that failed to validate. These messages can then be displayed to prompt your user to correct their submission.

This example renders an error banner under the `email` input when an invalid email is submitted:

```astro title=src/components/Newsletter.astro ins="isInputError" ins={18}
<form>
  <input required type="email" name="email" />
  <!--...--->
</form>

<script>
  import { actions, isInputError } from 'astro:actions';
  import { navigate } from 'astro:transitions/client';

  const form = document.querySelector('form') as HTMLFormElement;
  form.addEventListener('submit', async (e) => {
    e.preventDefault();
    const formData = new FormData(form);
    const { error } = await actions.newsletter(formData);
    if (!error) navigate('/confirmation');

    if (isInputError(error)) {
      const errorMessages = error.fields.email?.join(', ') ?? '';
      const banner = document.createElement('p');
      banner.textContent = errorMessages;
      const input = form.querySelector('input[name="email"]');
      input?.insertAdjacentElement('afterend', banner);
    }
  })
</script>
```

## Call actions from an HTML form action

:::note
Pages must be server rendered when calling actions using a form action. [Ensure prerendering is disabled on the page](/en/guides/server-side-rendering/#opting-out-of-pre-rendering-in-hybrid-mode) before using this API.
:::

You may want to pass `FormData` using a standard HTML form as well. This is useful as a fallback for client forms during slow internet connections or older devices. You may also prefer to handle forms entirely from the server using an Astro component.

To use a standard form request, add `method="POST"` as a form attribute to any `<form>` element. Then, apply action function directly to the form's `action` property (example: `action={actions.logout}`). This will apply the function name as a query string to be handled by the server automatically.

This example calls the `logout` action from a form using an Astro component, and re-renders the current page when it is complete:

```astro title="src/pages/index.astro"
---
import { actions } from 'astro:actions';
---

<form method="POST" action={actions.logout}>
  <!--output: action="?_astroAction=logout"-->
  <button>Log out</button>
</form>
```

You can also prepend a route you want to navigate if the action is successful. For example, `action={'/confirmation' + actions.newsletter}` will navigate to `/confirmation` when the `newsletter` action succeeds:

```astro title="src/pages/index.astro"
---
import { actions } from 'astro:actions';
---

<form method="POST" action={'/confirmation' + actions.newsletter}>
  <input required type="email" name="email" />
  <label>
    <input required type="checkbox" name="promo" />
    Receive occasional promo emails
  </label>
  <button>Sign up</button>
</form>
```

### Redirect to a constructed route on success

You may need to use the result of an action to construct a redirect path. This is common when creating a product record and redirecting to that product's page (example: `/products/[id]`).

For example, say you have a `createProduct()` action that returns the generated product id:

```ts title="src/actions/index.ts" mark={10}
import { defineAction } from 'astro:actions';
import { z } from 'astro:schema';

export const server = {
  createProduct: defineAction({
    accept: 'form',
    input: z.object({ /* ... */ }),
    handler: async (input) => {
      // persist product to database
      return { id: "example" };
    },
  })
}
```

If the action succeeded, retrieve the action result from your Astro component by calling `Astro.getActionResult()`. This returns a `data` or `error` object when an action is called, or `undefined` if no request was received.

Use the `data` property to construct a URL and return a `redirect` response with `Astro.redirect()`:

```astro title="src/pages/products/create.astro" ins={5-7}
---
import { actions } from 'astro:actions';

const result = Astro.getActionResult(actions.createProduct);
if (result && !result.error) {
  return Astro.redirect(`/products/${result.data.id}`);
}
---

<form method="POST" action={actions.createProduct}>
  <!--...-->
</form>
```

### Handle form action errors

Astro avoids redirecting to your `action` route when an action fails. Instead, the current page is re-rendered with any errors the action returned.

Check for errors by using the `error` object returned by `Astro.getActionResult()`. This example displays a general message when a `newsletter` action fails:

```astro title="src/pages/index.astro" ins={4,7}
---
import { actions } from 'astro:actions';

const result = Astro.getActionResult(actions.newsletter);
---

{result?.error && <p class="error">Unable to sign up. Please try again later.</p>}
<form method="POST" action={'/confirmation' + actions.newsletter}>
  <input required type="email" name="email" />
  <label>
    <input required type="checkbox" name="promo" />
    Receive occasional promo emails
  </label>
  <button>Sign up</button>
</form>
```

You can [use the `isInputError()` utility](#displaying-form-input-errors) to check whether an error is caused by invalid input. This example renders an error banner under the `email` input when an invalid email is submitted:

```astro title="src/pages/index.astro" ins={6,11}
---
// src/pages/index.astro
import { actions, isInputError } from 'astro:actions';

const result = Astro.getActionResult(actions.newsletter);
const inputErrors = isInputError(result?.error) ? result.error.fields : {};
---

<form method="POST" action={'/confirmation' + actions.newsletter}>
  <input required type="email" name="email" />
  {inputErrors.email && <p class="error">{inputErrors.email.join(',')}</p>}

  <!--...-->
</form>
```

:::note
Astro persists action `data` and `error` with a single-use cookie. This means `getActionResult()` will return a result on the first request _only_, and `undefined` when revisiting the page.
:::

#### Preserve input values on error

Inputs will be cleared whenever a form is submitted. To persist input values, you can [enable view transitions](/en/guides/view-transitions/#adding-view-transitions-to-a-page) on the page and apply the `transition:persist` directive to each input:

```astro ins="transition:persist"
<input transition:persist required type="email" name="email" />
```

### Update the UI with a form action result

The result returned by `Astro.getActionResult()` is single-use, and will reset to `undefined` whenever the page is refreshed. This is ideal for [displaying input errors](#handle-form-action-errors) and showing temporary notifications to the user on success.

:::tip
If you need a result to be displayed across page refreshes, consider storing the result in a database or [in a cookie](/en/reference/api-reference/#astrocookies).
:::

Call `Astro.getActionResult()` with a given action function, and use the `data` property to render any temporary UI you want to display. This example uses the `productName` property returned by an `addToCart` action to show a success message:

```astro title="src/pages/products/[slug].astro"
---
import { actions } from 'astro:actions';

const result = Astro.getActionResult(actions.addToCart);
---

{result && !result.error && (
  <p class="success">Added {result.data.productName} to cart</p>
)}

<!--...-->
```

:::caution
Action data is passed using a persisted cookie. **This cookie is not encrypted.** In general, we recommend returning the minimum information required from your action `handler` to avoid vulnerabilities, and persist other sensitive information in a database.

For example, you might return the name of a product in an `addToCart` action, rather than returning the entire `product` object:

```ts title="src/actions/index.ts" del={7} ins={8}
import { defineAction } from 'astro:actions';

export const server = {
  addToCard: defineAction({
    handler: async () => {
      /* ... */
      return product;
      return { productName: product.name };
    }
  })
}
```
:::
